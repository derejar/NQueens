# Решение задачи об N-ферзях
## Описание
Задача заключается в нахождении всех способов расстановки N ферзей на доске NxN таким образом, чтобы они не атаковали друг друга.  \
Решение реализовано при помощи поиска с возвратом в трех вариантах: с помощью простого массива std::array, с помощью своей реализации bitboard и с помощью std::bitset.
## BitBoard
Основной целью было изучение возможности выбора минимального типа данных для хранения доски NxN в побитовом виде с помощью шаблонов. Все доски со сторонами с 1 по 8 (включительно) размещаются в одном числе от 8 до 64 бит. Все доски больших размеров размещаются в массиве байт, имеющем размер, рассчитанный так, чтобы в нем можно было побитово разместить доску требуемого размера. \
В итоге получился интересный опыт с шаблонами и битовыми операциями.
## Замеры
Компиляция осуществлялась с помощью компилятора gcc v11.2.0 с флагом -O3. Время в замерах указано в миллисекундах.

* Array_Solution - Решение с применением std::array 
* BitBoard_Solution - Решение с применением разработанной реализации bitboard 
* Bitset_Solution - Решение с применением std::set 

N   | Array_Solution | BitBoard_Solution | Bitset_Solution | Count of solutions
:-: | :------------: | :---------------: | :-------------: | :-:
1   | 0.0001426      | 0.0001470         | 0.0001450       | 1
2   | 0.0000885      | 0.0001485         | 0.0000659       | 0
3   | 0.0002155      | 0.0001180         | 0.0001273       | 0
4   | 0.0009352      | 0.0011566         | 0.0011016       | 2
5   | 0.0021303      | 0.0022190         | 0.0023730       | 10
6   | 0.0103939      | 0.0109770         | 0.0203056       | 4
7   | 0.0535593      | 0.0558671         | 0.0698234       | 40
8   | 0.2417170      | 0.2150930         | 0.3172300       | 92
9   | 1.0931900      | 1.8310600         | 1.2828600       | 352
10  | 4.7905800      | 9.3552600         | 6.1302400       | 724
11  | 25.1163        | 45.4100           | 32.7482         | 2680
12  | 74.9124        | 113.186           | 73.346          | 14200
13  | 484.875        | 697.565           | 445.32          | 73712
14  | 2 652.48       | 4 171.87          | 2 634.95        | 365596
15  | 18 187.2       | 25 637            | 17 273.5        | 2279184

![1-5Queens](https://github.com/user-attachments/assets/97e82901-039a-49bd-9cdd-e5aabe8c2e05)
![6-10Queens](https://github.com/user-attachments/assets/3172bbd1-0132-4f02-9e14-c7bceed2bece)
![11-15Queens](https://github.com/user-attachments/assets/85c5c478-d7fb-4114-8421-6d0275fa7429)

## Результаты
Посмотрев на полученные графики можно увидеть, что наиболее эффективной реализацией по скорости работы оказалась реализация с помощью std::array. Скорее всего, компилятор справился с оптимизацией этого решения лучше, чем с оптимизацией решений с побитовыми операциями. \
Решение с помощью bitboard показало себя достаточно эффективным до тех пор, пока реализация bitboard не начала работать через массив байт (начиная с расстановки 9 и более ферзей). В этот момент время работы резко возрастает, сильно отставая от двух других реализаций.
